/*
 * StepDir.c
 *
 *  Created on: 08.12.2017
 *      Author: LH
 *
 *  Concept:
 *      A high frequency interrupt calculates Step/Dir outputs.
 *      The calculation uses 'sequence points' generated by the
 *      movement commands (rotate, moveTo etc.).
 *      The sequence points have a simple structure to them,
 *      one property as a trigger (velocity, position),
 *      a trigger value (position 1000, velocity 250) and a
 *      resulting action (set velocity to 500). This added
 *      together results in motions by a set of these sequence
 *      points:
 *
 *      Example: 6-point ramp velocity mode with sequence points:
 *      - no condition, set velocity to 10
 *      - no condition, set acceleration to 100
 *      - when velocity == 1000, set acceleration to 50
 *      - when velocity == 1500, set acceleration to 0
 *
 *      Sequence point conditions trigger whever they are reached or
 *      overshot - if we're rotating in a positive direction,
 *      setting sequence point condition position == 1000 while
 *      we're already at position 2000 will result in immediate
 *      execution of the sequence point action.
 *
 *      Sequence points are stored in a ring buffer. Unused sequence
 *      points have the trigger condition TRIGGER_NEVER.
 */

static StepDirChannel channels[CHANNELS] = { 0 };
static SequencePoint sequenceBuffer[CHANNELS][SEQUENCE_BUFFER_SIZE] = { 0 };
static uint8 sequenceIndex = 0;

void StepDir_init(void)
{
	for(int ch = 0; i < CHANNELS; i++)
	{
		// First Sequence buffer element state: never trigger -> no sequence execution
		sequenceBuffer[ch][0].condition  = TRIGGER_NEVER;
		sequenceIndex = 0;

		channels[ch].acceleration      = 0;
		channels[ch].velocity          = 0;
		channels[ch].position          = 0;
		channels[ch].velocityAccu      = 0;
		channels[ch].positionAccu      = 0;
		channels[ch].stallGuardActive  = 0;
		channels[ch].coolStepActive    = 0;
		channels[ch].channelHalted     = 1;
	}
}

void StepDir_tick(void)
{

	for(int ch = 0; i < CHANNELS; i++)
	{
		uint8 stepRequired = 0;

		// Helper variable for code readability
		StepDirChannel *currCh = channels[ch];

		if(!currCh->channelHalted)
		{
			// Calculate velocity
			currCh->velocityAccu += currCh->acceleration;
			if(currCh->velDirection == RIGHT)
				currCh->velocity += currCh->velocityAccu >> ACCUMULATOR_PRECISION;
			else
				currCh->velocity -= currCh->velocityAccu >> ACCUMULATOR_PRECISION;
			// Remove decimal places from accumulator
			currCh->velocityAccu -= currCh->velocityAccu >> ACCUMULATOR_PRECISION;

			// Calculate position
			currCh->positionAccu += currCh->velocity;
			// Clip maximum position change to 1, we can only generate 1 pulse per interrupt
			stepRequired = (currCh->positionAccu >> ACCUMULATOR_PRECISION)? 1 : 0;
			// Remove decimal places from accumulator
			currCh->positionAccu -= currCh->positionAccu >> ACCUMULATOR_PRECISION;
			// Add the step to position
			if(currCh->posDirection == RIGHT)
				currCh->position += stepRequired;
			else
				currCh->position -= stepRequired;
		}

		// Check for sequence points
		uint8 sequencePointHandled = 0;
		do {
			SequencePoint currPoint = sequenceBuffer[ch][sequenceIndex];
			switch(currPoint.condition)
			{
			case TRIGGER_NEVER:
				break;
			case TRIGGER_ALWAYS:
				sequencePointHandled = 1;
				break;
			case TRIGGER_VELOCITY_LT:  // velocity <= threshold
				if(currCh->velocity <= currPoint.threshold)
				{
					sequencePointHandled = 1;
					currCh->velocity = currPoint.threshold;
				}
				break;
			case TRIGGER_VELOCITY_GT:  // velocity >= threshold
				if(currCh->velocity >= currPoint.threshold)
				{
					sequencePointHandled = 1;
					currCh->velocity = currPoint.threshold;
				}
				break;
			case TRIGGER_POSITION_LT:  // position <= threshold
				if(currCh->position <= currPoint.threshold)
					sequencePointHandled = 1;
				break;
			case TRIGGER_POSITION_GT:  // position >= threshold
				if(currCh->position >= currPoint.threshold)
					sequencePointHandled = 1;
				break;
			}

			if(sequencePointHandled) {
				switch(currPoint.action)
				{
				case ACTION_STOP:
					currCh->channelHalted = 1;
					break;
				case ACTION_NONE:
					break;
				case ACTION_ACCELERATION:
					currCh->acceleration = currPoint.value;
					break;
				case ACTION_VELOCITY:
					currCh->velocity = currPoint.value;
					break;
				case ACTION_POSITION:
					currCh->position = currPoint.value;
					break;
				}
				// Move the ring buffer index
				sequenceIndex = (sequenceIndex + 1) % SEQUENCE_BUFFER_SIZE;
			}
		} while(sequencePointHandled);
		// Check sequence point(s)
		// Adjust parameters (clip velocity/position if required, store new values for next iteration)
		// Do the step
	}
}
